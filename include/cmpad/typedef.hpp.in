// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
// SPDX-FileCopyrightText: Bradley M. Bell <bradbell@seanet.com>
// SPDX-FileContributor: 2023 Bradley M. Bell
// ---------------------------------------------------------------------------
# ifndef CMPAD_TYPEDEF_HPP
# define CMPAD_TYPEDEF_HPP
/*
{xrst_begin cmpad_typedef}
{xrst_spell
   cmake
   cppad
   std
   str
   vec
}

The cmpad::vector Template Class
################################

option_t
********
{xrst_literal
   // BEGIN OPTION_T
   // END OPTION_T
}

vec_vec_str
***********
{xrst_literal
   // BEGIN VEC_VEC_STR
   // END VEC_VEC_STR
}

cmpad::vector
*************
The cmpad cmake command line determines the ``cmpad::vector`` template class
in the following way. If

|   ``-D cmpad_vector=`` *vector_type*

is present on the cmake command line, *vector_type* must be
``std`` , ``boost`` , or ``cppad``;
see below for the corresponding definition.
If *vector_type* is not on the cmake command line, ``std`` is used.

std
===
{xrst_literal
   cmpad_vector_is_std
   // END std
}

boost
=====
{xrst_literal
   cmpad_vector_is_boost
   // END boost
}

cppad
=====
{xrst_literal
   cmpad_vector_is_cppad
   // END cppad
}

{xrst_end cmpad_typedef}
*/
// BEGIN OPTION_T
namespace cmpad { struct option_t { size_t size; }; }
// END OPTION_T

# if @cmpad_vector_is_std@
# include<vector>
namespace cmpad { using std::vector; }
# endif // END std

# if @cmpad_vector_is_boost@
# include<boost/numeric/ublas/vector.hpp>
namespace cmpad { using boost::numeric::ublas::vector; }
# endif // END boost

# if @cmpad_vector_is_cppad@
# include<cppad/utility/vector.hpp>
namespace cmpad { using CppAD::vector; }
# endif // END cppad

// BEGIN VEC_VEC_STR
# include <string>
namespace cmpad {
   typedef cmpad::vector< cmpad::vector<std::string> > vec_vec_str;
}
// END VEC_VEC_STR


# endif
